<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tournament Menu</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" />
  <link href="/css/styles.css" rel="stylesheet" />
  <style>
    /* Estilos para el canvas del juego */
    canvas {
      border: 1px solid #000;
      background-color: rgb(85, 5, 45);
    }
    /* Estilo principal de la página */
    h1 {
      color: rgb(28, 42, 236);
      font-size: 3rem;
      font-family: 'roboto';
    }
    #welcomeMessage {
      margin-bottom: 20px;
    }
    #createTournamentBtn {
      margin-bottom: 20px;
    }
    /* Secciones de nombres y scores (ocultas por defecto; se muestran solo en partida) */
    #playerNames, #scores {
      display: none;
      margin-bottom: 20px;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
    }
    #playerNames p, #scores p {
      font-size: 1.5rem;
      font-weight: bold;
      color: #343a40;
      margin: 0.5rem 0;
    }
    /* Contenedor principal para la UI del match (enfrentamiento actual, anuncios, etc.) */
    #matchPlayers {
      font-size: 2rem;
      color: #fff;
      background-color: #007bff;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 20px;
    }
    /* Encabezado cuando el torneo finaliza */
    #matchPlayers h3 {
      margin: 0;
      font-size: 2.5rem;
      color: #ffcc00;
    }
    /* Contenedor para la lista de partidos pendientes del torneo (opcional) */
    #tournamentPendingMatches {
      display: none;
      margin-top: 10px;
      font-size: 1.2rem;
      color: #007bff;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container mt-5">
    <!-- Sección de formularios: creación de torneo, agregar participantes, etc. -->
    <div id="welcomeMessage" class="mb-3"></div>
    <h1>Tournament Menu</h1>
    <button id="createTournamentBtn" class="btn btn-primary mb-3">Create Tournament</button>
    <div id="createTournamentForm" class="mb-3" style="display: none;">
      <h2>Create Tournament</h2>
      <form id="tournamentForm">
        <div class="mb-3">
          <label for="tournamentName" class="form-label">Tournament Name</label>
          <input type="text" class="form-control" id="tournamentName" required />
        </div>
        <div class="mb-3">
          <label for="maxMatchPoints" class="form-label">Max Match Points</label>
          <input type="number" class="form-control" id="maxMatchPoints" required />
        </div>
        <div class="mb-3">
          <label for="numberOfPlayers" class="form-label">Number of Players</label>
          <input type="number" class="form-control" id="numberOfPlayers" required />
        </div>
        <button type="submit" class="btn btn-success">Next</button>
        <button type="button" id="cancelTournamentBtn" class="btn btn-secondary">Cancel</button>
      </form>
    </div>
    <div id="addParticipantsForm" class="mb-3" style="display: none;">
      <h2>Add Participants</h2>
      <form id="participantForm">
        <div class="mb-3">
          <label for="participantName" class="form-label">Participant Name</label>
          <input type="text" class="form-control" id="participantName" required />
        </div>
        <button type="submit" class="btn btn-success">Add Participant</button>
        <button type="button" id="createTournamentFinalBtn" class="btn btn-primary" style="display: none;">Create Tournament</button>
        <button type="button" id="cancelParticipantsBtn" class="btn btn-secondary">Cancel</button>
      </form>
      <p id="participantsCount" class="mt-3">0 / 0 participantes</p>
      <ul id="participantsList" class="list-group mt-3"></ul>
    </div>
    <!-- Listados de torneos jugados y pendientes (se actualizan mediante llamadas a la API sin recargar la página) -->
    <h2>Played Tournaments</h2>
    <ul id="playedTournamentsList" class="list-group mb-3"></ul>
    <h2>Pending Tournaments</h2>
    <ul id="pendingTournamentsList" class="list-group"></ul>
    <!-- UI para el match en curso (enfrentamiento actual, resultados, anuncios, etc.) -->  
    <div id="matchPlayers"></div>
    <!-- Sección para mostrar los nombres de los jugadores (solo durante la partida) -->  
    <div id="playerNames">
      <p id="player1Name"></p>
      <p id="player2Name"></p>
    </div>
    <!-- Sección para mostrar los puntajes (solo durante la partida) -->  
    <div id="scores">
      <p id="player1Score"></p>
      <p id="player2Score"></p>
    </div>
    <!-- Contenedor para la lista de partidos pendientes del torneo (opcional) -->  
    <div id="tournamentPendingMatches"></div>
    <!-- Canvas del juego (inicialmente oculto) -->  
    <canvas id="canvasId" width="1000" height="600" style="display: none;"></canvas>
  </div>

  <script>
    // Guardamos una referencia global al menú para actualizar la UI sin recargar la página completa
    let tournamentMenuInstance;

    /*------------------------------------------------------------------*/
    /*  SERVICES: Clases para llamadas a la API                         */
    /*------------------------------------------------------------------*/
    class UserService {
      static async fetchCurrentUser() {
        const response = await fetch('/api/tournament/current_user/');
        return response.json();
      }
    }

    class TournamentService {
      static API_URL = '/api/tournament';

      static async fetchPlayedTournaments() {
        const response = await fetch(`${this.API_URL}/played_tournaments/`);
        return response.json();
      }

      static async fetchPendingTournaments() {
        const response = await fetch(`${this.API_URL}/pending_tournaments/`);
        return response.json();
      }

      static async fetchTournament(tournamentId) {
        const response = await fetch(`${this.API_URL}/tournament_detail/${tournamentId}/`);
        return response.json();
      }

      static async fetchTournamentMatches(tournamentId) {
        const response = await fetch(`${this.API_URL}/tournament_matches/${tournamentId}/`);
        return response.json();
      }

      static async updateMatch(matchId, player1Points, player2Points) {
        const response = await fetch(`${this.API_URL}/start_match/${matchId}/`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ player1Points, player2Points })
        });
        return response.json();
      }

      static async startTournament(tournamentId) {
        const response = await fetch(`${this.API_URL}/start_tournament/${tournamentId}/`, {
          method: 'POST'
        });
        return response.json();
      }

      static async createTournament(data) {
        const response = await fetch(`${this.API_URL}/create_tournament/`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        return response.json();
      }

      static async deleteTournament(tournamentId) {
        const response = await fetch(`${this.API_URL}/delete_tournament/${tournamentId}/`, {
          method: 'DELETE'
        });
        return response.json();
      }
    }

    /*------------------------------------------------------------------*/
    /*  TOURNAMENT MENU CLASS - Gestión de la interfaz principal de torneos  */
    /*------------------------------------------------------------------*/
    class TournamentMenu {
      constructor() {
        this.welcomeMessageContainer = document.getElementById('welcomeMessage');
        this.createTournamentBtn = document.getElementById('createTournamentBtn');
        this.cancelTournamentBtn = document.getElementById('cancelTournamentBtn');
        this.tournamentForm = document.getElementById('tournamentForm');
        this.createTournamentForm = document.getElementById('createTournamentForm');
        this.addParticipantsForm = document.getElementById('addParticipantsForm');
        this.participantForm = document.getElementById('participantForm');
        this.participantNameInput = document.getElementById('participantName');
        this.participantsList = document.getElementById('participantsList');
        this.createTournamentFinalBtn = document.getElementById('createTournamentFinalBtn');
        this.cancelParticipantsBtn = document.getElementById('cancelParticipantsBtn');
        this.participantsCount = document.getElementById('participantsCount');
        this.playedTournamentsList = document.getElementById('playedTournamentsList');
        this.pendingTournamentsList = document.getElementById('pendingTournamentsList');

        this.participants = [];
        this.maxParticipants = 0;

        this.init();
      }

      async init() {
        // Asignar eventos a botones y formularios
        this.createTournamentBtn.addEventListener('click', () => this.showCreateTournamentForm());
        this.cancelTournamentBtn.addEventListener('click', () => this.hideCreateTournamentForm());

        this.tournamentForm.addEventListener('submit', (event) => {
          event.preventDefault();
          this.maxParticipants = parseInt(document.getElementById('numberOfPlayers').value);
          this.showAddParticipantsForm();
        });

        this.participantForm.addEventListener('submit', (event) => {
          event.preventDefault();
          const participantName = this.participantNameInput.value;
          this.addParticipant(participantName);
        });

        this.createTournamentFinalBtn.addEventListener('click', async () => {
          const data = {
            name: document.getElementById('tournamentName').value,
            max_match_points: document.getElementById('maxMatchPoints').value,
            number_of_players: this.maxParticipants,
            participants: this.participants
          };
          const response = await TournamentService.createTournament(data);
          if (response.error) {
            console.error(response.error);
          } else {
            this.hideAddParticipantsForm();
            this.loadTournaments();
          }
        });

        this.cancelParticipantsBtn.addEventListener('click', () => this.hideAddParticipantsForm());

        const currentUser = await UserService.fetchCurrentUser();
        this.renderWelcomeMessage(currentUser);
        this.loadTournaments();
      }

      showCreateTournamentForm() {
        this.createTournamentForm.style.display = 'block';
      }

      hideCreateTournamentForm() {
        this.createTournamentForm.style.display = 'none';
      }

      showAddParticipantsForm() {
        this.createTournamentForm.style.display = 'none';
        this.addParticipantsForm.style.display = 'block';
        UserService.fetchCurrentUser().then(user => {
          if (!this.participants.includes(user.username)) {
            this.addParticipant(user.username);
          }
        });
      }

      hideAddParticipantsForm() {
        this.addParticipantsForm.style.display = 'none';
        this.participants = [];
        this.participantsList.innerHTML = '';
        this.participantNameInput.disabled = false;
        this.createTournamentFinalBtn.style.display = 'none';
      }

      addParticipant(name) {
        if (this.participants.length < this.maxParticipants) {
          this.participants.push(name);
          const li = document.createElement('li');
          li.className = 'list-group-item';
          li.textContent = name;
          this.participantsList.appendChild(li);
          this.participantNameInput.value = '';
          this.updateParticipantsCount();
          if (this.participants.length === this.maxParticipants) {
            this.participantNameInput.disabled = true;
            this.createTournamentFinalBtn.style.display = 'block';
          }
        }
      }

      updateParticipantsCount() {
        this.participantsCount.textContent = `${this.participants.length} / ${this.maxParticipants} participantes`;
      }

      renderWelcomeMessage(user) {
        this.welcomeMessageContainer.innerHTML = `<h1>Hola, ${user.username}</h1>
          <p>Esta página es para crear y monitorear tus torneos.</p>`;
      }

      async loadTournaments() {
        const playedTournaments = await TournamentService.fetchPlayedTournaments();
        this.renderPlayedTournaments(playedTournaments);
        const pendingTournaments = await TournamentService.fetchPendingTournaments();
        this.renderPendingTournaments(pendingTournaments);
      }

      renderPlayedTournaments(tournaments) {
        this.playedTournamentsList.innerHTML = '';
        tournaments.forEach(tournament => {
          const li = document.createElement('li');
          li.className = 'list-group-item';
          li.innerHTML = `<h5>${tournament.name}</h5>
            <p>Participants: ${tournament.participants.map(p => p.username).join(', ')}</p>
            <p>Winner: ${tournament.winner ? tournament.winner.username : 'TBD'}</p>
            <button class="btn btn-danger" onclick="TournamentService.deleteTournament(${tournament.id}).then(() => { window.tournamentMenuInstance.loadTournaments(); })">Delete</button>`;
          this.playedTournamentsList.appendChild(li);
        });
      }

      renderPendingTournaments(tournaments) {
        this.pendingTournamentsList.innerHTML = '';
        tournaments.forEach(tournament => {
          const li = document.createElement('li');
          li.className = 'list-group-item';
          li.innerHTML = `<h5>${tournament.name}</h5>
            <p>Creator: ${tournament.creator.username}</p>
            <p>Max Match Points: ${tournament.max_match_points}</p>
            <p>Participants: ${tournament.participants.map(p => p.username).join(', ')}</p>
            <p>Pending Matches: ${tournament.pending_matches.map(m => `${m.player1.username} vs ${m.player2.username}`).join(', ')}</p>`;
          const startBtn = document.createElement('button');
          startBtn.textContent = 'Start Tournament';
          startBtn.className = 'btn btn-primary';
          startBtn.addEventListener('click', () => new Tournament(tournament.id));
          li.appendChild(startBtn);
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = 'Delete';
          deleteBtn.className = 'btn btn-danger ms-2';
          deleteBtn.addEventListener('click', () => {
            TournamentService.deleteTournament(tournament.id).then(() => this.loadTournaments());
          });
          li.appendChild(deleteBtn);
          this.pendingTournamentsList.appendChild(li);
        });
      }
    }
    
    /*------------------------------------------------------------------*/
    /*  TOURNAMENT CLASS - Lógica del torneo (partidas, transición, etc.)    */
    /*------------------------------------------------------------------*/
    class Tournament {
      constructor(tournamentId) {
        this.tournamentId = tournamentId;
        this.currentMatchIndex = 0;
        this.matches = [];
        this.maxMatchPoints = 0;
        this.init();
      }
    
      async init() {
        const response = await TournamentService.startTournament(this.tournamentId);
        if (response.message) {
          this.matches = await TournamentService.fetchTournamentMatches(this.tournamentId);
          const tournamentDetail = await TournamentService.fetchTournament(this.tournamentId);
          this.maxMatchPoints = tournamentDetail.max_match_points;
          // Filtrar solo partidos no jugados
          this.matches = this.matches.filter(match => !match.played);
          if (this.matches.length > 0) {
            this.startMatch(this.matches[this.currentMatchIndex]);
          } else {
            this.showTournamentFinishedUI();
          }
        } else {
          console.error('Error al iniciar el torneo');
        }
      }
    
      // Muestra la partida actual y reinicia la UI de nombres y scores.
      // Los contenedores de nombres y scores se muestran SOLO durante la partida.
      startMatch(match) {
        const matchContainer = document.getElementById('matchPlayers');
        matchContainer.innerHTML = '';
        const header = document.createElement('h2');
        header.textContent = `${match.player1.username} vs ${match.player2.username}`;
        matchContainer.appendChild(header);
        // Mostrar nombres y scores SOLO durante la partida
        document.getElementById('playerNames').style.display = 'block';
        document.getElementById('player1Name').textContent = `Player 1 (Left): ${match.player1.username}`;
        document.getElementById('player2Name').textContent = `Player 2 (Right): ${match.player2.username}`;
        document.getElementById('scores').style.display = 'block';
        document.getElementById('player1Score').textContent = 'Score: 0';
        document.getElementById('player2Score').textContent = 'Score: 0';
        // Botón para iniciar la partida
        const startMatchBtn = document.createElement('button');
        startMatchBtn.textContent = 'Start Match';
        startMatchBtn.className = 'btn btn-success mt-3';
        startMatchBtn.id = 'startMatchBtn';
        startMatchBtn.addEventListener('click', () => {
          startMatchBtn.remove();
          this.launchGame(match);
        });
        matchContainer.appendChild(startMatchBtn);
      }
    
      // Lanza el juego: se muestra el canvas y se crea la instancia de Game.
      // Al finalizar, se ocultan los contenedores de nombres y scores, y se muestra el resultado.
      launchGame(match) {
        const canvas = document.getElementById('canvasId');
        canvas.style.display = 'block';
        new Game(canvas, match, this.maxMatchPoints, (player1Points, player2Points, winner) => {
          canvas.style.display = 'none';
          TournamentService.updateMatch(match.id, player1Points, player2Points);
          // Ocultar nombres y scores al finalizar la partida
          document.getElementById('playerNames').style.display = 'none';
          document.getElementById('scores').style.display = 'none';
          document.getElementById('player1Score').textContent = '';
          document.getElementById('player2Score').textContent = '';
          this.showMatchResult(match, player1Points, player2Points, winner);
        });
      }
    
      // Muestra el resultado de la partida y un botón "Aceptar" que actualiza la lista de torneos sin recargar la página completa.
      showMatchResult(match, player1Points, player2Points, winner) {
        let winningPlayer, losingPlayer;
        if (winner === 'Player1') {
          winningPlayer = match.player1.username;
          losingPlayer = match.player2.username;
        } else {
          winningPlayer = match.player2.username;
          losingPlayer = match.player1.username;
        }
        const matchContainer = document.getElementById('matchPlayers');
        matchContainer.innerHTML = `<h3>Match Finished!</h3>
          <p>${winningPlayer} defeated ${losingPlayer} with score ${player1Points} - ${player2Points}</p>`;
        const acceptBtn = document.createElement('button');
        acceptBtn.textContent = 'Aceptar';
        acceptBtn.className = 'btn btn-success mt-3';
        acceptBtn.addEventListener('click', () => {
          acceptBtn.remove();
          // Actualizamos la lista de torneos sin recargar la página completa
          if (window.tournamentMenuInstance) {
            window.tournamentMenuInstance.loadTournaments();
          }
          this.showNextMatchAnnouncement();
        });
        matchContainer.appendChild(acceptBtn);
      }
    
      // Anuncia el siguiente partido; si hay más, se inicia la siguiente partida; si no, se muestra que el torneo finalizó.
      showNextMatchAnnouncement() {
        if (this.currentMatchIndex + 1 < this.matches.length) {
          const nextMatch = this.matches[this.currentMatchIndex + 1];
          const matchContainer = document.getElementById('matchPlayers');
          matchContainer.innerHTML = `<h3>Next Match</h3>
            <p>${nextMatch.player1.username} vs ${nextMatch.player2.username}</p>`;
          const acceptBtn = document.createElement('button');
          acceptBtn.textContent = 'Aceptar';
          acceptBtn.className = 'btn btn-success mt-3';
          acceptBtn.addEventListener('click', () => {
            acceptBtn.remove();
            this.currentMatchIndex++;
            this.startMatch(this.matches[this.currentMatchIndex]);
          });
          matchContainer.appendChild(acceptBtn);
        } else {
          this.showTournamentFinishedUI();
        }
      }
    
      // Cuando el torneo ha finalizado, se muestra un mensaje y un botón "Aceptar" que actualiza la lista de torneos sin recargar la página completa.
      showTournamentFinishedUI() {
        const matchContainer = document.getElementById('matchPlayers');
        matchContainer.innerHTML = '<h3>Tournament finished!</h3>';
        const reloadBtn = document.createElement('button');
        reloadBtn.textContent = 'Aceptar';
        reloadBtn.className = 'btn btn-success mt-3';
        reloadBtn.addEventListener('click', () => {
          if (window.tournamentMenuInstance) {
            //window.tournamentMenuInstance.loadTournaments();
            window.location.reload();
          }
        });
        matchContainer.appendChild(reloadBtn);
      }
    }
    
    /*------------------------------------------------------------------*/
    /*  CLASSES FOR GAME, PADDLE, AND BALL                                */
    /*------------------------------------------------------------------*/
    class Ball {
      constructor(pos, vel, rad) {
        this.pos = pos;
        this.vel = vel;
        this.rad = rad;
      }
      update() {
        this.pos.x += this.vel.x;
        this.pos.y += this.vel.y;
      }
      draw(ctx) {
        ctx.fillStyle = 'green';
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.rad, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    class Paddle {
      constructor(pos, width, height, isLeft) {
        this.pos = pos;
        this.width = width;
        this.height = height;
        this.isLeft = isLeft;
        this.score = 0;
      }
      update(keys, KEY_W, KEY_S, KEY_UP, KEY_DOWN, canvasHeight, speed) {
        if (this.isLeft) {
          if (keys[KEY_W]) this.pos.y -= speed;
          if (keys[KEY_S]) this.pos.y += speed;
        } else {
          if (keys[KEY_UP]) this.pos.y -= speed;
          if (keys[KEY_DOWN]) this.pos.y += speed;
        }
        if (this.pos.y < 0) this.pos.y = 0;
        if (this.pos.y + this.height > canvasHeight) this.pos.y = canvasHeight - this.height;
      }
      draw(ctx) {
        ctx.fillStyle = 'gray';
        ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
      }
    }
    
    class Game {
      constructor(canvas, match, maxPoints, onGameEnd) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.match = match;
        this.maxPoints = maxPoints;
        this.onGameEnd = onGameEnd;
        this.animationFrameId = null;
        this.PLAYER_SPEED = 7;
        this.keys = {};
        this.KEY_UP = 38;
        this.KEY_DOWN = 40;
        this.KEY_W = 87;
        this.KEY_S = 83;
        this.gameEnded = false;
        this.canvas.width = 1000;
        this.canvas.height = 600;
        this.ball = new Ball({ x: 200, y: 200 }, { x: 7, y: 7 }, 10);
        this.paddle1 = new Paddle({ x: 10, y: 250 }, 10, 160, true);
        this.paddle2 = new Paddle({ x: this.canvas.width - 20, y: 250 }, 10, 160, false);
        window.addEventListener('keydown', (e) => { this.keys[e.keyCode] = true; });
        window.addEventListener('keyup', (e) => { this.keys[e.keyCode] = false; });
        this.loop = this.loop.bind(this);
        this.loop();
      }
      ballCollisionWithEdges() {
        if (this.ball.pos.y + this.ball.rad >= this.canvas.height) {
          this.ball.pos.y = this.canvas.height - this.ball.rad;
          this.ball.vel.y *= -1;
        } else if (this.ball.pos.y - this.ball.rad <= 0) {
          this.ball.pos.y = this.ball.rad;
          this.ball.vel.y *= -1;
        }
      }
      ballCollisionWithPaddle(paddle) {
        // Calcular la distancia entre el centro de la pelota y el centro de la pala
        let dx = Math.abs(this.ball.pos.x - paddle.pos.x - paddle.width / 2);
        let dy = Math.abs(this.ball.pos.y - paddle.pos.y - paddle.height / 2);

        if (dx <= (this.ball.rad + paddle.width / 2) && dy <= (this.ball.rad + paddle.height / 2)) {
            // Colisión detectada
            if (dx > paddle.width / 2) {
                // Colisión en los lados izquierdo o derecho
                this.ball.vel.x *= -1;
                if (this.ball.pos.x < paddle.pos.x) {
                    this.ball.pos.x = paddle.pos.x - this.ball.rad;
                } else {
                    this.ball.pos.x = paddle.pos.x + paddle.width + this.ball.rad;
                }
            } else if (dy > paddle.height / 2) {
                // Colisión en los bordes superior o inferior
                this.ball.vel.y *= -1;
                if (this.ball.pos.y < paddle.pos.y) {
                    this.ball.pos.y = paddle.pos.y - this.ball.rad;
                } else {
                    this.ball.pos.y = paddle.pos.y + paddle.height + this.ball.rad;
                }
            } else {
                // Colisión en las esquinas
                this.ball.vel.x *= -1;
                this.ball.vel.y *= -1;
                // Ajusta la posición de la pelota para evitar que se quede atrapada en la esquina
                if (this.ball.pos.x < paddle.pos.x) {
                    this.ball.pos.x = paddle.pos.x - this.ball.rad;
                } else if (this.ball.pos.x > paddle.pos.x + paddle.width) {
                    this.ball.pos.x = paddle.pos.x + paddle.width + this.ball.rad;
                }
                if (this.ball.pos.y < paddle.pos.y) {
                    this.ball.pos.y = paddle.pos.y - this.ball.rad;
                } else if (this.ball.pos.y > paddle.pos.y + paddle.height) {
                    this.ball.pos.y = paddle.pos.y + paddle.height + ball.rad;
                }
            }
        }
      }
      respawnBall() {
        this.ball.pos.x = this.canvas.width / 2;
        this.ball.pos.y = Math.random() * this.canvas.height;
        this.ball.vel.x *= -1;
      }
      increaseScore() {
        if (this.ball.pos.x <= -this.ball.rad) {
          this.paddle2.score++;
          this.respawnBall();
        }
        if (this.ball.pos.x >= this.canvas.width + this.ball.rad) {
          this.paddle1.score++;
          this.respawnBall();
        }
      }
      updateScores() {
        document.getElementById('player1Score').textContent = `Score: ${this.paddle1.score}`;
        document.getElementById('player2Score').textContent = `Score: ${this.paddle2.score}`;
      }
      checkGameEnd() {
        if (this.paddle1.score >= this.maxPoints) {
          this.stopGameAndFinish(this.paddle1.score, this.paddle2.score, 'Player1');
        } else if (this.paddle2.score >= this.maxPoints) {
          this.stopGameAndFinish(this.paddle1.score, this.paddle2.score, 'Player2');
        }
      }
      stopGameAndFinish(player1Points, player2Points, winner) {
        if (this.gameEnded) return;
        this.gameEnded = true;
        cancelAnimationFrame(this.animationFrameId);
        if (this.onGameEnd) this.onGameEnd(player1Points, player2Points, winner);
      }
      loop() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ball.update();
        this.paddle1.update(this.keys, this.KEY_W, this.KEY_S, this.KEY_UP, this.KEY_DOWN, this.canvas.height, this.PLAYER_SPEED);
        this.paddle2.update(this.keys, this.KEY_W, this.KEY_S, this.KEY_UP, this.KEY_DOWN, this.canvas.height, this.PLAYER_SPEED);
        this.ballCollisionWithEdges();
        this.ballCollisionWithPaddle(this.paddle1);
        this.ballCollisionWithPaddle(this.paddle2);
        this.increaseScore();
        this.updateScores();
        this.checkGameEnd();
        this.gameDraw();
        this.animationFrameId = requestAnimationFrame(this.loop);
      }
      gameDraw() {
        this.ball.draw(this.ctx);
        this.paddle1.draw(this.ctx);
        this.paddle2.draw(this.ctx);
      }
    }
    
    // Al cargar el DOM, se crea una instancia global de TournamentMenu para actualizar la UI sin recargar la página completa
    document.addEventListener('DOMContentLoaded', () => {
      window.tournamentMenuInstance = new TournamentMenu();
    });
  </script>
</body>
</html>
